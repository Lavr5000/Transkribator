---
phase: 01-critical-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backends/sherpa_backend.py
  - RemotePackage/src/backends/sherpa_backend.py
autonomous: true

must_haves:
  truths:
    - "Sherpa backend использует Transducer режим вместо CTC"
    - "Sherpa backend использует правильные файлы модели (encoder/decoder/joiner)"
    - "Sherpa backend использует max_active_paths=4 для оптимальной точности"
  artifacts:
    - path: "src/backends/sherpa_backend.py"
      contains: "from_nemo_transducer"
      contains: "encoder="
      contains: "decoder="
      contains: "joiner="
      contains: "max_active_paths=4"
    - path: "RemotePackage/src/backends/sherpa_backend.py"
      contains: "from_nemo_transducer"
  key_links:
    - from: "src/backends/sherpa_backend.py"
      to: "sherpa_onnx.OfflineRecognizer.from_nemo_transducer"
      via: "load_model method"
      pattern: "from_nemo_transducer\("
---

<objective>
Fix Sherpa backend architecture from CTC to Transducer mode.

**What:**
Critical bug fix: GigaAM v2 is a Transducer model, but current code uses CTC mode. This causes significant accuracy loss.

**Why:**
Using wrong architecture (CTC instead of Transducer) means the model processes audio incorrectly, leading to "торопинка или сок" instead of "тропинка лесок". This is the PRIMARY cause of poor quality.

**Output:**
Updated sherpa_backend.py using from_nemo_transducer() with correct model files.
</objective>

<execution_context>
@C:\Users\user\.claude\get-shit-down\workflows\execute-plan.md
@C:\Users\user\.claude\get-shit-down\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md

# Critical bug location
C:\Users\user\.claude\0 ProEKTi\Transkribator\src\backends\sherpa_backend.py line 162

# GigaAM v2 model files needed:
# - encoder.int8.onnx (or encoder.onnx)
# - decoder.onnx
# - joiner.onnx
# - tokens.txt
</context>

<tasks>

<task type="auto">
  <name>Fix Sherpa backend: CTC to Transducer architecture</name>
  <files>src/backends/sherpa_backend.py, RemotePackage/src/backends/sherpa_backend.py</files>
  <action>
In both sherpa_backend.py files:

1. Update MODELS dictionary to reflect Transducer model files (line 34-55):
```python
# OLD (replace):
MODELS = {
    "giga-am-v2-ru": {
        "name": "GigaAM v2 Russian (2025-04-19)",
        "url": "https://huggingface.co/csukuangfj/sherpa-onnx-nemo-ctc-giga-am-v2-russian-2025-04-19",
        "files": [
            "model.onnx",
            "tokens.txt",
            "config.json"
        ],
        "language": "ru",
    },
    # ...
}

# NEW (replace with):
MODELS = {
    "giga-am-v2-ru": {
        "name": "GigaAM v2 Russian Transducer (2025-04-19)",
        "url": "https://huggingface.co/csukuangfj/sherpa-onnx-nemo-transducer-giga-am-v2-russian-2025-04-19",
        "files": [
            "encoder.int8.onnx",
            "decoder.onnx",
            "joiner.onnx",
            "tokens.txt"
        ],
        "language": "ru",
    },
    "giga-am-ru": {
        "name": "GigaAM Russian Transducer (2024-10-24)",
        "url": "https://huggingface.co/csukuangfj/sherpa-onnx-nemo-transducer-giga-am-russian-2024-10-24",
        "files": [
            "encoder.int8.onnx",
            "decoder.onnx",
            "joiner.onnx",
            "tokens.txt"
        ],
        "language": "ru",
    },
}
```

2. Update _check_model_files() to check for Transducer files (line 103-125):
```python
# Add check for Transducer model files (after existing checks)
# Check for encoder/decoder/joiner files (Transducer mode)
has_transducer = (
    (model_dir / "encoder.int8.onnx").exists() or (model_dir / "encoder.onnx").exists()
) and (model_dir / "decoder.onnx").exists() and (model_dir / "joiner.onnx").exists()

# Cache the result (update line 124)
self._model_files_checked = has_transducer
return has_transducer
```

3. Replace load_model() recognizer creation (line 161-170):
```python
# OLD (delete entire section):
# Create recognizer using factory method for NeMo CTC models
self._recognizer = sherpa_onnx.OfflineRecognizer.from_nemo_ctc(
    model=str(model_file),
    tokens=str(tokens_file),
    num_threads=self.num_threads,
    sample_rate=16000,
    feature_dim=80,
    decoding_method="greedy_search",
    debug=False,
)

# NEW (replace with):
# Create recognizer using Transducer mode (GigaAM v2 is Transducer, NOT CTC!)
encoder_file = model_dir / "encoder.int8.onnx"
if not encoder_file.exists():
    encoder_file = model_dir / "encoder.onnx"

decoder_file = model_dir / "decoder.onnx"
joiner_file = model_dir / "joiner.onnx"

self._recognizer = sherpa_onnx.OfflineRecognizer.from_nemo_transducer(
    encoder=str(encoder_file),
    decoder=str(decoder_file),
    joiner=str(joiner_file),
    tokens=str(tokens_file),
    num_threads=self.num_threads,
    sample_rate=16000,
    max_active_paths=4,  # Optimal balance of speed vs accuracy for Russian
    debug=False,
)
```
  </action>
  <verify>grep -n "from_nemo_transducer" src/backends/sherpa_backend.py RemotePackage/src/backends/sherpa_backend.py</verify>
  <done>Both files use from_nemo_transducer with encoder/decoder/joiner files and max_active_paths=4</done>
</task>

</tasks>

<verification>
After implementation:
1. grep confirms "from_nemo_transducer" in both files
2. grep confirms "max_active_paths=4" in both files
3. grep confirms encoder/decoder/joiner references
4. No references to "from_nemo_ctc" remain
</verification>

<success_criteria>
- [ ] Sherpa backend uses from_nemo_transducer() (NOT from_nemo_ctc)
- [ ] Model files check includes encoder.int8.onnx, decoder.onnx, joiner.onnx
- [ ] max_active_paths=4 set for optimal Russian accuracy
- [ ] Changes synchronized between local and RemotePackage versions
</success_criteria>

<output>
After completion, create .planning/phases/01-critical-bug-fixes/01-02-SUMMARY.md
</output>
