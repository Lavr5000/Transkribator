---
phase: 03-text-processing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/text_processor_enhanced.py
  - src/phonetics.py
autonomous: true

must_haves:
  truths:
    - "Phonetic corrections apply to 6 voiced/unvoiced consonant pairs (б↔п, в↔ф, г↔к, д↔т, ж↔ш, з↔с)"
    - "Corrections are context-aware (word-end devoicing, pre-voiced assimilation)"
    - "Substitutions validated against vocabulary to avoid over-correction"
    - "Phonetic module integrates with EnhancedTextProcessor"
  artifacts:
    - path: "src/phonetics.py"
      provides: "Phonetic correction module with context-aware rules"
      min_lines: 80
      exports: ["PhoneticCorrector", "fix_voiced_unvoiced"]
    - path: "src/text_processor_enhanced.py"
      provides: "Integration with phonetic corrections"
      contains: "from .phonetics import"
  key_links:
    - from: "src/text_processor_enhanced.py"
      to: "src/phonetics.py"
      via: "import PhoneticCorrector"
      pattern: "from \.phonetics import|phonetics\.PhoneticCorrector"
---

# Plan: Add phonetic corrections for Russian language

## Objective

Implement context-aware phonetic corrections for Russian voiced/unvoiced consonant pairs. Addresses POST-02 requirement for fixing systematic ASR substitutions (б↔п, в↔ф, г↔к, д↔т, ж↔ш, з↔с).

**Purpose:** Russian ASR models confuse voiced/unvoiced consonants at word boundaries and in rapid speech. Sherpa-ONNX produces errors like "неверо" instead of "небе", "кодоф" instead of "готов". Context-aware corrections reduce CER by 3-5%.

**Output:** New `src/phonetics.py` module with `PhoneticCorrector` class, integrated into `EnhancedTextProcessor`. Validates substitutions against vocabulary to avoid over-correction (prevents "кодов" -> "котов").

## Context

@.planning/phases/03-text-processing/03-CONTEXT.md
@.planning/phases/03-text-processing/03-RESEARCH.md
@src/text_processor_enhanced.py

Research findings:
- Use 6 basic pairs: б↔п, в↔ф, г↔к, д↔т, ж↔ш, з↔с
- Apply at word endings (оглушение) and before other consonants (assimilation)
- Validate with pymorphy2 to check if corrected word is valid Russian
- DO NOT apply globally (breaks "кодов", "гриб", etc.)

## Tasks

<task type="auto">
  <name>Task 1: Create phonetics module with voiced/unvoiced mappings</name>
  <files>src/phonetics.py</files>
  <action>
    Create new src/phonetics.py with:

    1. VOICED_UNVOICED_MAP dict:
       VOICED_UNVOICED = {
           'б': 'п', 'п': 'б',
           'в': 'ф', 'ф': 'в',
           'г': 'к', 'к': 'г',
           'д': 'т', 'т': 'д',
           'ж': 'ш', 'ш': 'ж',
           'з': 'с', 'с': 'з',
       }

    2. PhoneticCorrector class with:
       - __init__(self): optional pymorphy2 MorphAnalyzer for validation
       - _is_valid_russian_word(self, word: str) -> bool: checks if word exists in vocabulary
       - fix_word_end_devoicing(self, text: str) -> str: fixes "неверо" -> "небе"
       - fix_pre_voiced_assimilation(self, text: str) -> str: fixes "кодо" -> "готов"
       - process(self, text: str) -> str: applies all phonetic corrections

    Key implementation details:
    - Try substitution only if original word NOT in vocabulary AND substituted word IS
    - Use pymorphy2.MorphAnalyzer().parse() to check word validity
    - Cache MorphAnalyzer as class attribute (singleton pattern)
    - Handle word boundaries with regex \b
  </action>
  <verify>File exists with VOICED_UNVOICED_MAP and PhoneticCorrector class</verify>
  <done>Phonetics module created with voiced/unvoiced mappings</done>
</task>

<task type="auto">
  <name>Task 2: Implement word-end devoicing correction</name>
  <files>src/phonetics.py</files>
  <action>
    Implement fix_word_end_devoicing() method:

    Logic:
    1. Split text into words
    2. For each word ending in voiced consonant (б, в, г, д, ж, з):
       - Try unvoiced variant (replace last letter with pair)
       - If unvoiced in vocabulary AND original not in vocabulary -> use unvoiced
    3. For each word ending in unvoiced consonant (п, ф, к, т, ш, с):
       - Try voiced variant
       - If voiced in vocabulary AND original not in vocabulary -> use voiced

    Examples:
    - "неверо" -> try "небе" -> valid if "небе" in vocab and "неверо" not
    - "кодов" -> try "катов" -> REJECT if "кодов" is valid word (don't break valid words)

    Use pymorphy2 for vocabulary check:
    ```python
    parsed = morph.parse(word)
    is_valid = any(p.score > 0.5 for p in parsed)
    ```
  </action>
  <verify>Method handles word-end devoicing with vocabulary validation</verify>
  <done>Word-end corrections implemented with validation</done>
</task>

<task type="auto">
  <name>Task 3: Implement pre-voiced assimilation correction</name>
  <files>src/phonetics.py</files>
  <action>
    Implement fix_pre_voiced_assimilation() method:

    Logic (regressive assimilation of voicing):
    1. Find consonant clusters within words
    2. If voiced + unvoiced cluster (e.g., "кодо" where д becomes т before voiceless):
       - Try voiced variant of second consonant
    3. Validate both original and corrected word

    Russian rule: Voiced consonants devoice before voiceless consonants.
    ASR error: Sometimes applies too aggressively or misses it.

    Examples (ASR errors):
    - "кодо" (should be "готов") - д devoiced to т before в (but ASR got devoiced version)
    - "леск" (should be "лес") - optional, less common

    Focus on:
    - Word-internal consonant clusters
    - Pre-voicing where ASR devoiced incorrectly
  </action>
  <verify>Method handles pre-voiced assimilation patterns</verify>
  <done>Pre-voiced assimilation corrections implemented</done>
</task>

<task type="auto">
  <name>Task 4: Integrate phonetic corrections into EnhancedTextProcessor</name>
  <files>src/text_processor_enhanced.py</files>
  <action>
    Import and use PhoneticCorrector in EnhancedTextProcessor:

    1. Add import: from .phonetics import PhoneticCorrector
    2. In __init__:
       - self.phonetic_corrector = PhoneticCorrector()
    3. In process() method:
       - Add phonetic correction step AFTER dictionary corrections
       - BEFORE punctuation restoration
       - text = self.phonetic_corrector.process(text)

    Processing order in process():
    1. Fix common errors (_fix_errors)
    2. Phonetic corrections (NEW - step 2)
    3. Add punctuation (_add_punctuation)
    4. Fix punctuation placement (_fix_punctuation)
    5. Fix capitalization (_fix_capitalization)
    6. Final cleanup (_cleanup)

    Make pymorphy2 optional (try/except ImportError) - skip validation if not installed.
  </action>
  <verify>EnhancedTextProcessor imports and uses PhoneticCorrector</verify>
  <done>Phonetic corrections integrated into processing pipeline</done>
</task>

## Verification

1. Module test: `from src.phonetics import PhoneticCorrector`
2. Word-end test: "неверо" -> "небе"
3. Validation test: "кодов" stays "кодов" (not over-corrected)
4. Integration test: EnhancedTextProcessor applies phonetic fixes

## Success Criteria

- [ ] PhoneticCorrector class with 6 consonant pairs
- [ ] Word-end devoicing correction with validation
- [ ] Pre-voiced assimilation correction
- [ ] Integration with EnhancedTextProcessor
- [ ] No over-correction of valid words

## Output

After completion, create `.planning/phases/03-text-processing/03-02-SUMMARY.md` with:
- Consonant pairs implemented
- Vocabulary validation approach
- Sample corrections (before/after)
- Performance notes (pymorphy2 caching)
